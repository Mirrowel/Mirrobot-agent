name: Bot Reply on Mention

on:
  issue_comment:
    types: [created]

jobs:
  continuous-reply:
    if: ${{ contains(github.event.comment.body, '@mirrobot') || contains(github.event.comment.body, '@mirrobot-agent') }}
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write

    env:
      THREAD_NUMBER: ${{ github.event.issue.number }}

    steps:

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Bot Setup
        id: setup
        uses: ./.github/actions/bot-setup
        with:
          bot-app-id: ${{ secrets.BOT_APP_ID }}
          bot-private-key: ${{ secrets.BOT_PRIVATE_KEY }}
          opencode-api-key: ${{ secrets.OPENCODE_API_KEY }}
          opencode-model: ${{ secrets.OPENCODE_MODEL }}
          opencode-fast-model: ${{ secrets.OPENCODE_FAST_MODEL }}
          custom-providers-json: ${{ secrets.CUSTOM_PROVIDERS_JSON }}

      - name: Add reaction to comment
        env:
          GH_TOKEN: ${{ steps.setup.outputs.token }}
        run: |
          gh api \
            --method POST \
            -H "Accept: application/vnd.github+json" \
            /repos/${{ github.repository }}/issues/comments/${{ github.event.comment.id }}/reactions \
            -f content='eyes'

      - name: Gather Full Thread Context
        id: context
        env:
          GH_TOKEN: ${{ steps.setup.outputs.token }}
        run: |
          # Common Info
          echo "NEW_COMMENT_AUTHOR=${{ github.event.comment.user.login }}" >> $GITHUB_ENV
          # Use a unique delimiter for safety
          COMMENT_DELIMITER="GH_BODY_DELIMITER_$(openssl rand -hex 8)"
          { echo "NEW_COMMENT_BODY<<$COMMENT_DELIMITER"; echo "${{ github.event.comment.body }}"; echo "$COMMENT_DELIMITER"; } >> "$GITHUB_ENV"
          # Determine if PR or Issue
          if [ -n '${{ github.event.issue.pull_request }}' ]; then
            IS_PR="true"
          else
            IS_PR="false"
          fi
          echo "IS_PR=$IS_PR" >> $GITHUB_OUTPUT
          # Define a unique, random delimiter for the main context block
          CONTEXT_DELIMITER="GH_CONTEXT_DELIMITER_$(openssl rand -hex 8)"
          # Fetch and Format Context based on type
          if [[ "$IS_PR" == "true" ]]; then
            # Fetch PR data
            pr_json=$(gh pr view ${{ env.THREAD_NUMBER }} --repo ${{ github.repository }} --json author,title,body,createdAt,state,headRefName,baseRefName,headRefOid,additions,deletions,commits,files,comments,reviews,closingIssuesReferences)
            # Fetch review comments separately
            review_comments_json=$(gh api "/repos/${{ github.repository }}/pulls/${{ env.THREAD_NUMBER }}/comments")

            # Debug: Output pr_json and review_comments_json for inspection
            echo "$pr_json" > pr_json.txt
            echo "$review_comments_json" > review_comments_json.txt

            # Fetch timeline data to find cross-references
            timeline_data=$(gh api "/repos/${{ github.repository }}/issues/${{ env.THREAD_NUMBER }}/timeline")

            # Fetch the diff to enable code review strategy
            echo "Fetching PR diff..."
            diff_content=$(gh pr diff ${{ env.THREAD_NUMBER }} --repo ${{ github.repository }} || echo "Failed to fetch diff.")

            # For checkout step
            echo "repo_full_name=$(echo "$pr_json" | jq -r '.headRepository.nameWithOwner // "${{ github.repository }}"')" >> $GITHUB_OUTPUT
            echo "ref_name=$(echo "$pr_json" | jq -r .headRefName)" >> $GITHUB_OUTPUT
           
            # For prompt context
            echo "PR_HEAD_SHA=$(echo "$pr_json" | jq -r .headRefOid)" >> $GITHUB_ENV
            echo "THREAD_AUTHOR=$(echo "$pr_json" | jq -r .author.login)" >> $GITHUB_ENV
            # Prepare all variables from JSON
            author=$(echo "$pr_json" | jq -r .author.login)
            created_at=$(echo "$pr_json" | jq -r .createdAt)
            base_branch=$(echo "$pr_json" | jq -r .baseRefName)
            head_branch=$(echo "$pr_json" | jq -r .headRefName)
            state=$(echo "$pr_json" | jq -r .state)
            additions=$(echo "$pr_json" | jq -r .additions)
            deletions=$(echo "$pr_json" | jq -r .deletions)
            total_commits=$(echo "$pr_json" | jq -r '.commits | length')
            changed_files_count=$(echo "$pr_json" | jq -r '.files | length')
            title=$(echo "$pr_json" | jq -r .title)
            body=$(echo "$pr_json" | jq -r .body)
            # Prepare changed files list
            changed_files_list=$(echo "$pr_json" | jq -r '.files[] | "- \(.path) (MODIFIED) +\((.additions))/-((.deletions))"')
            # Prepare general PR comments
            comments=$(echo "$pr_json" | jq -r 'if (.comments | length) > 0 then .comments[] | "- \(.author.login // "unknown") at \(.createdAt // "N/A"):\n\(.body // "")\n" else "No general comments." end')
            
            # ===== ENHANCED FILTERING WITH ERROR HANDLING =====
            
            # Count totals before filtering
            total_reviews=$(echo "$pr_json" | jq '[.reviews[] | select(.author.login != "ellipsis-dev")] | length')
            total_review_comments=$(echo "$review_comments_json" | jq '[.[] | select(.user.login != "ellipsis-dev")] | length')
            
            # Prepare reviews: exclude COMMENTED (duplicates inline comments) and DISMISSED states
            # Fallback to unfiltered if jq fails
            if reviews=$(echo "$pr_json" | jq -r 'if (.reviews | length) > 0 then (.reviews[] | select(.author.login != "ellipsis-dev" and .body != null and .state != "COMMENTED" and .state != "DISMISSED") | "- \(.author.login // "unknown") at \(.createdAt // "N/A"):\n - Review body: \(.body // "No summary comment.")\n - State: \(.state // "UNKNOWN")\n") else "No formal reviews." end' 2>/dev/null); then
              filtered_reviews=$(echo "$reviews" | grep -c "^- " || echo "0")
              excluded_reviews=$((total_reviews - filtered_reviews))
              echo "✓ Filtered reviews: $filtered_reviews included, $excluded_reviews excluded (COMMENTED/DISMISSED)"
            else
              echo "::warning::Review filtering failed, using unfiltered data"
              reviews=$(echo "$pr_json" | jq -r 'if (.reviews | length) > 0 then (.reviews[] | select(.author.login != "ellipsis-dev" and .body != null) | "- \(.author.login // "unknown") at \(.createdAt // "N/A"):\n - Review body: \(.body // "No summary comment.")\n - State: \(.state // "UNKNOWN")\n") else "No formal reviews." end')
              excluded_reviews=0
            fi
            
            # Prepare review comments: exclude outdated comments
            # Fallback to unfiltered if jq fails
            if review_comments=$(echo "$review_comments_json" | jq -r 'if (length > 0) then (.[] | select(.user.login != "ellipsis-dev" and (.outdated == false or .outdated == null)) | .pull_request_review_id as $review_id | "- \(.user.login // "unknown") (Review ID: \($review_id // "N/A")) at \(.created_at // "N/A"):\n - Inline Comment: \(.path):\(.line // "N/A"):\n   \(.body // "")\n") else "No inline review comments." end' 2>/dev/null); then
              filtered_comments=$(echo "$review_comments" | grep -c "^- " || echo "0")
              excluded_comments=$((total_review_comments - filtered_comments))
              echo "✓ Filtered review comments: $filtered_comments included, $excluded_comments excluded (outdated)"
            else
              echo "::warning::Review comment filtering failed, using unfiltered data"
              review_comments=$(echo "$review_comments_json" | jq -r 'if (length > 0) then (.[] | select(.user.login != "ellipsis-dev") | .pull_request_review_id as $review_id | "- \(.user.login // "unknown") (Review ID: \($review_id // "N/A")) at \(.created_at // "N/A"):\n - Inline Comment: \(.path):\(.line // "N/A"):\n   \(.body // "")\n") else "No inline review comments." end')
              excluded_comments=0
            fi
            
            # Build filtering summary
            filter_summary="Context filtering applied: $excluded_reviews reviews and $excluded_comments review comments excluded from this context."

            # Prepare linked issues robustly by fetching each one individually.
            linked_issues_content=""
            issue_numbers=$(echo "$pr_json" | jq -r '.closingIssuesReferences[].number')

            if [ -z "$issue_numbers" ]; then
              linked_issues="No issues are formally linked for closure by this PR."
            else
              for number in $issue_numbers; do
                # Fetch each issue's data separately. This is more reliable for cross-repo issues or permission nuances.
                issue_details_json=$(gh issue view "$number" --repo "${{ github.repository }}" --json title,body 2>/dev/null || echo "{}")
                
                issue_title=$(echo "$issue_details_json" | jq -r '.title // "Title not available"')
                issue_body=$(echo "$issue_details_json" | jq -r '.body // "Body not available"')
                linked_issues_content+=$(printf "<issue>\n <number>#%s</number>\n <title>%s</title>\n <body>\n%s\n</body>\n</issue>\n" "$number" "$issue_title" "$issue_body")
              done
              linked_issues=$linked_issues_content
            fi

            # Prepare cross-references from timeline data
            references=$(echo "$timeline_data" | jq -r '.[] | select(.event == "cross-referenced") | .source.issue | "- Mentioned in \(.html_url | if contains("/pull/") then "PR" else "Issue" end): #\(.number) - \(.title)"')
            if [ -z "$references" ]; then references="This PR has not been mentioned in other issues or PRs."; fi
            
            # Step 1: Write the header for the multi-line environment variable
            echo "THREAD_CONTEXT<<$CONTEXT_DELIMITER" >> "$GITHUB_ENV"
            # Step 2: Append the content line by line
            echo "Type: Pull Request" >> "$GITHUB_ENV"
            echo "PR Number: #${{ env.THREAD_NUMBER }}" >> "$GITHUB_ENV"
            echo "Title: $title" >> "$GITHUB_ENV"
            echo "Author: $author" >> "$GITHUB_ENV"
            echo "Created At: $created_at" >> "$GITHUB_ENV"
            echo "Base Branch: $base_branch" >> "$GITHUB_ENV"
            echo "Head Branch: $head_branch" >> "$GITHUB_ENV"
            echo "State: $state" >> "$GITHUB_ENV"
            echo "Additions: $additions" >> "$GITHUB_ENV"
            echo "Deletions: $deletions" >> "$GITHUB_ENV"
            echo "Total Commits: $total_commits" >> "$GITHUB_ENV"
            echo "Changed Files: $changed_files_count files" >> "$GITHUB_ENV"
            echo "<diff>" >> "$GITHUB_ENV"
            echo "$diff_content" >> "$GITHUB_ENV"
            echo "</diff>" >> "$GITHUB_ENV"
            echo "<pull_request_body>" >> "$GITHUB_ENV"
            echo "$body" >> "$GITHUB_ENV"
            echo "</pull_request_body>" >> "$GITHUB_ENV"
            echo "<pull_request_comments>" >> "$GITHUB_ENV"
            echo "$comments" >> "$GITHUB_ENV"
            echo "</pull_request_comments>" >> "$GITHUB_ENV"
            echo "<pull_request_reviews>" >> "$GITHUB_ENV"
            echo "$reviews" >> "$GITHUB_ENV"
            echo "</pull_request_reviews>" >> "$GITHUB_ENV"
            echo "<pull_request_review_comments>" >> "$GITHUB_ENV"
            echo "$review_comments" >> "$GITHUB_ENV"
            echo "</pull_request_review_comments>" >> "$GITHUB_ENV"
            echo "<pull_request_changed_files>" >> "$GITHUB_ENV"
            echo "$changed_files_list" >> "$GITHUB_ENV"
            echo "</pull_request_changed_files>" >> "$GITHUB_ENV"
            echo "<linked_issues>" >> "$GITHUB_ENV"
            echo "$linked_issues" >> "$GITHUB_ENV"
            echo "</linked_issues>" >> "$GITHUB_ENV"

            # Step 3: Write the closing delimiter
            # Add cross-references and filtering summary to the final context
            echo "<cross_references>" >> "$GITHUB_ENV"
            echo "$references" >> "$GITHUB_ENV"
            echo "</cross_references>" >> "$GITHUB_ENV"
            echo "<filtering_summary>" >> "$GITHUB_ENV"
            echo "$filter_summary" >> "$GITHUB_ENV"
            echo "</filtering_summary>" >> "$GITHUB_ENV"

            echo "$CONTEXT_DELIMITER" >> "$GITHUB_ENV"
          else # It's an Issue
            issue_data=$(gh issue view ${{ env.THREAD_NUMBER }} --repo ${{ github.repository }} --json author,title,body,createdAt,state,comments)
            timeline_data=$(gh api "/repos/${{ github.repository }}/issues/${{ env.THREAD_NUMBER }}/timeline")
            echo "THREAD_AUTHOR=$(echo "$issue_data" | jq -r .author.login)" >> $GITHUB_ENV
            # Prepare metadata
            author=$(echo "$issue_data" | jq -r .author.login)
            created_at=$(echo "$issue_data" | jq -r .createdAt)
            state=$(echo "$issue_data" | jq -r .state)
            title=$(echo "$issue_data" | jq -r .title)
            body=$(echo "$issue_data" | jq -r .body)
            # Prepare comments
            comments=$(echo "$issue_data" | jq -r 'if (.comments | length) > 0 then .comments[] | "- \(.author.login // "unknown") at \(.createdAt // "N/A"):\n\(.body // "")\n" else "No comments have been posted yet." end')

            # Prepare cross-references
            references=$(echo "$timeline_data" | jq -r '.[] | select(.event == "cross-referenced") | .source.issue | "- Mentioned in \(.html_url | if contains("/pull/") then "PR" else "Issue" end): #\(.number) - \(.title)"')
            if [ -z "$references" ]; then references="No other issues or PRs have mentioned this thread."; fi

            # Step 1: Write the header
            echo "THREAD_CONTEXT<<$CONTEXT_DELIMITER" >> "$GITHUB_ENV"
            # Step 2: Append the content line by line
            echo "Type: Issue" >> "$GITHUB_ENV"
            echo "Issue Number: #${{ env.THREAD_NUMBER }}" >> "$GITHUB_ENV"
            echo "Title: $title" >> "$GITHUB_ENV"
            echo "Author: $author" >> "$GITHUB_ENV"
            echo "Created At: $created_at" >> "$GITHUB_ENV"
            echo "State: $state" >> "$GITHUB_ENV"
            echo "<issue_body>" >> "$GITHUB_ENV"
            echo "$body" >> "$GITHUB_ENV"
            echo "</issue_body>" >> "$GITHUB_ENV"
            echo "<issue_comments>" >> "$GITHUB_ENV"
            echo "$comments" >> "$GITHUB_ENV"
            echo "</issue_comments>" >> "$GITHUB_ENV"
            echo "<cross_references>" >> "$GITHUB_ENV"
            echo "$references" >> "$GITHUB_ENV"
            echo "</cross_references>" >> "$GITHUB_ENV"
            # Step 3: Write the footer
            echo "$CONTEXT_DELIMITER" >> "$GITHUB_ENV"
          fi

      - name: Save secure prompt from base branch
        if: steps.context.outputs.IS_PR == 'true'
        run: cp .github/prompts/bot-reply.md /tmp/bot-reply.md

      - name: Checkout PR head
        if: steps.context.outputs.IS_PR == 'true'
        uses: actions/checkout@v4
        with:
          repository: ${{ steps.context.outputs.repo_full_name }}
          ref: ${{ steps.context.outputs.ref_name }}
          token: ${{ steps.setup.outputs.token }}
          fetch-depth: 0

      - name: Checkout repository (for issues)
        if: steps.context.outputs.IS_PR == 'false'
        uses: actions/checkout@v4
        with:
          token: ${{ steps.setup.outputs.token }}
          fetch-depth: 0

      - name: Analyze comment and respond
        env:
          GITHUB_TOKEN: ${{ steps.setup.outputs.token }}
          THREAD_CONTEXT: ${{ env.THREAD_CONTEXT }}
          NEW_COMMENT_AUTHOR: ${{ env.NEW_COMMENT_AUTHOR }}
          NEW_COMMENT_BODY: ${{ env.NEW_COMMENT_BODY }}
          THREAD_NUMBER: ${{ env.THREAD_NUMBER }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          THREAD_AUTHOR: ${{ env.THREAD_AUTHOR }}
          PR_HEAD_SHA: ${{ env.PR_HEAD_SHA }}
          OPENCODE_PERMISSION: |
            {
              "bash": {
                "gh*": "allow",
                "git*": "allow"
              },
              "webfetch": "deny"
            }
        run: |
            envsubst < /tmp/bot-reply.md | opencode run --share -